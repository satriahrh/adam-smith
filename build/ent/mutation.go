// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"

	"github.com/satriahrh/adam-smith/build/ent/brand"
	"github.com/satriahrh/adam-smith/build/ent/outbounddeal"
	"github.com/satriahrh/adam-smith/build/ent/outboundshipping"
	"github.com/satriahrh/adam-smith/build/ent/outboundtransaction"
	"github.com/satriahrh/adam-smith/build/ent/predicate"
	"github.com/satriahrh/adam-smith/build/ent/product"
	"github.com/satriahrh/adam-smith/build/ent/variant"
	"github.com/satriahrh/adam-smith/build/ent/variation"
	"github.com/satriahrh/adam-smith/ent/schema"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBrand               = "Brand"
	TypeOutboundDeal        = "OutboundDeal"
	TypeOutboundShipping    = "OutboundShipping"
	TypeOutboundTransaction = "OutboundTransaction"
	TypeProduct             = "Product"
	TypeVariant             = "Variant"
	TypeVariation           = "Variation"
)

// BrandMutation represents an operation that mutate the Brands
// nodes in the graph.
type BrandMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	code            *string
	name            *string
	clearedFields   map[string]struct{}
	products        map[uint64]struct{}
	removedproducts map[uint64]struct{}
	clearedproducts bool
	done            bool
	oldValue        func(context.Context) (*Brand, error)
	predicates      []predicate.Brand
}

var _ ent.Mutation = (*BrandMutation)(nil)

// brandOption allows to manage the mutation configuration using functional options.
type brandOption func(*BrandMutation)

// newBrandMutation creates new mutation for Brand.
func newBrandMutation(c config, op Op, opts ...brandOption) *BrandMutation {
	m := &BrandMutation{
		config:        c,
		op:            op,
		typ:           TypeBrand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBrandID sets the id field of the mutation.
func withBrandID(id uint64) brandOption {
	return func(m *BrandMutation) {
		var (
			err   error
			once  sync.Once
			value *Brand
		)
		m.oldValue = func(ctx context.Context) (*Brand, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Brand.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBrand sets the old Brand of the mutation.
func withBrand(node *Brand) brandOption {
	return func(m *BrandMutation) {
		m.oldValue = func(context.Context) (*Brand, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BrandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BrandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BrandMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCode sets the code field.
func (m *BrandMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *BrandMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the Brand.
// If the Brand object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BrandMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *BrandMutation) ResetCode() {
	m.code = nil
}

// SetName sets the name field.
func (m *BrandMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *BrandMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Brand.
// If the Brand object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BrandMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *BrandMutation) ResetName() {
	m.name = nil
}

// AddProductIDs adds the products edge to Product by ids.
func (m *BrandMutation) AddProductIDs(ids ...uint64) {
	if m.products == nil {
		m.products = make(map[uint64]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the products edge to Product.
func (m *BrandMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared returns if the edge products was cleared.
func (m *BrandMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the products edge to Product by ids.
func (m *BrandMutation) RemoveProductIDs(ids ...uint64) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[uint64]struct{})
	}
	for i := range ids {
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed ids of products.
func (m *BrandMutation) RemovedProductsIDs() (ids []uint64) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the products ids in the mutation.
func (m *BrandMutation) ProductsIDs() (ids []uint64) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts reset all changes of the "products" edge.
func (m *BrandMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Op returns the operation name.
func (m *BrandMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Brand).
func (m *BrandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BrandMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.code != nil {
		fields = append(fields, brand.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, brand.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BrandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case brand.FieldCode:
		return m.Code()
	case brand.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BrandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case brand.FieldCode:
		return m.OldCode(ctx)
	case brand.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Brand field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BrandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case brand.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case brand.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Brand field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BrandMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BrandMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BrandMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Brand numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BrandMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BrandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BrandMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Brand nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BrandMutation) ResetField(name string) error {
	switch name {
	case brand.FieldCode:
		m.ResetCode()
		return nil
	case brand.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Brand field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BrandMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.products != nil {
		edges = append(edges, brand.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BrandMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case brand.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BrandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproducts != nil {
		edges = append(edges, brand.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BrandMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case brand.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BrandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproducts {
		edges = append(edges, brand.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BrandMutation) EdgeCleared(name string) bool {
	switch name {
	case brand.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BrandMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Brand unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BrandMutation) ResetEdge(name string) error {
	switch name {
	case brand.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown Brand edge %s", name)
}

// OutboundDealMutation represents an operation that mutate the OutboundDeals
// nodes in the graph.
type OutboundDealMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint64
	quantity           *uint
	addquantity        *uint
	amount             *uint
	addamount          *uint
	clearedFields      map[string]struct{}
	variant            *uint64
	clearedvariant     bool
	parent             *uint64
	clearedparent      bool
	children           map[uint64]struct{}
	removedchildren    map[uint64]struct{}
	clearedchildren    bool
	transaction        *uint64
	clearedtransaction bool
	done               bool
	oldValue           func(context.Context) (*OutboundDeal, error)
	predicates         []predicate.OutboundDeal
}

var _ ent.Mutation = (*OutboundDealMutation)(nil)

// outbounddealOption allows to manage the mutation configuration using functional options.
type outbounddealOption func(*OutboundDealMutation)

// newOutboundDealMutation creates new mutation for OutboundDeal.
func newOutboundDealMutation(c config, op Op, opts ...outbounddealOption) *OutboundDealMutation {
	m := &OutboundDealMutation{
		config:        c,
		op:            op,
		typ:           TypeOutboundDeal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutboundDealID sets the id field of the mutation.
func withOutboundDealID(id uint64) outbounddealOption {
	return func(m *OutboundDealMutation) {
		var (
			err   error
			once  sync.Once
			value *OutboundDeal
		)
		m.oldValue = func(ctx context.Context) (*OutboundDeal, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutboundDeal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutboundDeal sets the old OutboundDeal of the mutation.
func withOutboundDeal(node *OutboundDeal) outbounddealOption {
	return func(m *OutboundDealMutation) {
		m.oldValue = func(context.Context) (*OutboundDeal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutboundDealMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutboundDealMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *OutboundDealMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetQuantity sets the quantity field.
func (m *OutboundDealMutation) SetQuantity(u uint) {
	m.quantity = &u
	m.addquantity = nil
}

// Quantity returns the quantity value in the mutation.
func (m *OutboundDealMutation) Quantity() (r uint, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old quantity value of the OutboundDeal.
// If the OutboundDeal object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OutboundDealMutation) OldQuantity(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuantity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds u to quantity.
func (m *OutboundDealMutation) AddQuantity(u uint) {
	if m.addquantity != nil {
		*m.addquantity += u
	} else {
		m.addquantity = &u
	}
}

// AddedQuantity returns the value that was added to the quantity field in this mutation.
func (m *OutboundDealMutation) AddedQuantity() (r uint, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity reset all changes of the "quantity" field.
func (m *OutboundDealMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetAmount sets the amount field.
func (m *OutboundDealMutation) SetAmount(u uint) {
	m.amount = &u
	m.addamount = nil
}

// Amount returns the amount value in the mutation.
func (m *OutboundDealMutation) Amount() (r uint, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old amount value of the OutboundDeal.
// If the OutboundDeal object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OutboundDealMutation) OldAmount(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds u to amount.
func (m *OutboundDealMutation) AddAmount(u uint) {
	if m.addamount != nil {
		*m.addamount += u
	} else {
		m.addamount = &u
	}
}

// AddedAmount returns the value that was added to the amount field in this mutation.
func (m *OutboundDealMutation) AddedAmount() (r uint, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount reset all changes of the "amount" field.
func (m *OutboundDealMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetVariantID sets the variant edge to Variant by id.
func (m *OutboundDealMutation) SetVariantID(id uint64) {
	m.variant = &id
}

// ClearVariant clears the variant edge to Variant.
func (m *OutboundDealMutation) ClearVariant() {
	m.clearedvariant = true
}

// VariantCleared returns if the edge variant was cleared.
func (m *OutboundDealMutation) VariantCleared() bool {
	return m.clearedvariant
}

// VariantID returns the variant id in the mutation.
func (m *OutboundDealMutation) VariantID() (id uint64, exists bool) {
	if m.variant != nil {
		return *m.variant, true
	}
	return
}

// VariantIDs returns the variant ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// VariantID instead. It exists only for internal usage by the builders.
func (m *OutboundDealMutation) VariantIDs() (ids []uint64) {
	if id := m.variant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVariant reset all changes of the "variant" edge.
func (m *OutboundDealMutation) ResetVariant() {
	m.variant = nil
	m.clearedvariant = false
}

// SetParentID sets the parent edge to OutboundDeal by id.
func (m *OutboundDealMutation) SetParentID(id uint64) {
	m.parent = &id
}

// ClearParent clears the parent edge to OutboundDeal.
func (m *OutboundDealMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared returns if the edge parent was cleared.
func (m *OutboundDealMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the parent id in the mutation.
func (m *OutboundDealMutation) ParentID() (id uint64, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the parent ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OutboundDealMutation) ParentIDs() (ids []uint64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent reset all changes of the "parent" edge.
func (m *OutboundDealMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the children edge to OutboundDeal by ids.
func (m *OutboundDealMutation) AddChildIDs(ids ...uint64) {
	if m.children == nil {
		m.children = make(map[uint64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the children edge to OutboundDeal.
func (m *OutboundDealMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared returns if the edge children was cleared.
func (m *OutboundDealMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the children edge to OutboundDeal by ids.
func (m *OutboundDealMutation) RemoveChildIDs(ids ...uint64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uint64]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed ids of children.
func (m *OutboundDealMutation) RemovedChildrenIDs() (ids []uint64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the children ids in the mutation.
func (m *OutboundDealMutation) ChildrenIDs() (ids []uint64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren reset all changes of the "children" edge.
func (m *OutboundDealMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// SetTransactionID sets the transaction edge to OutboundTransaction by id.
func (m *OutboundDealMutation) SetTransactionID(id uint64) {
	m.transaction = &id
}

// ClearTransaction clears the transaction edge to OutboundTransaction.
func (m *OutboundDealMutation) ClearTransaction() {
	m.clearedtransaction = true
}

// TransactionCleared returns if the edge transaction was cleared.
func (m *OutboundDealMutation) TransactionCleared() bool {
	return m.clearedtransaction
}

// TransactionID returns the transaction id in the mutation.
func (m *OutboundDealMutation) TransactionID() (id uint64, exists bool) {
	if m.transaction != nil {
		return *m.transaction, true
	}
	return
}

// TransactionIDs returns the transaction ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TransactionID instead. It exists only for internal usage by the builders.
func (m *OutboundDealMutation) TransactionIDs() (ids []uint64) {
	if id := m.transaction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransaction reset all changes of the "transaction" edge.
func (m *OutboundDealMutation) ResetTransaction() {
	m.transaction = nil
	m.clearedtransaction = false
}

// Op returns the operation name.
func (m *OutboundDealMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OutboundDeal).
func (m *OutboundDealMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *OutboundDealMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.quantity != nil {
		fields = append(fields, outbounddeal.FieldQuantity)
	}
	if m.amount != nil {
		fields = append(fields, outbounddeal.FieldAmount)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *OutboundDealMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outbounddeal.FieldQuantity:
		return m.Quantity()
	case outbounddeal.FieldAmount:
		return m.Amount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *OutboundDealMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outbounddeal.FieldQuantity:
		return m.OldQuantity(ctx)
	case outbounddeal.FieldAmount:
		return m.OldAmount(ctx)
	}
	return nil, fmt.Errorf("unknown OutboundDeal field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OutboundDealMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outbounddeal.FieldQuantity:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case outbounddeal.FieldAmount:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	}
	return fmt.Errorf("unknown OutboundDeal field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *OutboundDealMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, outbounddeal.FieldQuantity)
	}
	if m.addamount != nil {
		fields = append(fields, outbounddeal.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *OutboundDealMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case outbounddeal.FieldQuantity:
		return m.AddedQuantity()
	case outbounddeal.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OutboundDealMutation) AddField(name string, value ent.Value) error {
	switch name {
	case outbounddeal.FieldQuantity:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case outbounddeal.FieldAmount:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown OutboundDeal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *OutboundDealMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *OutboundDealMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutboundDealMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OutboundDeal nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *OutboundDealMutation) ResetField(name string) error {
	switch name {
	case outbounddeal.FieldQuantity:
		m.ResetQuantity()
		return nil
	case outbounddeal.FieldAmount:
		m.ResetAmount()
		return nil
	}
	return fmt.Errorf("unknown OutboundDeal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *OutboundDealMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.variant != nil {
		edges = append(edges, outbounddeal.EdgeVariant)
	}
	if m.parent != nil {
		edges = append(edges, outbounddeal.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, outbounddeal.EdgeChildren)
	}
	if m.transaction != nil {
		edges = append(edges, outbounddeal.EdgeTransaction)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *OutboundDealMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case outbounddeal.EdgeVariant:
		if id := m.variant; id != nil {
			return []ent.Value{*id}
		}
	case outbounddeal.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case outbounddeal.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case outbounddeal.EdgeTransaction:
		if id := m.transaction; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *OutboundDealMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, outbounddeal.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *OutboundDealMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case outbounddeal.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *OutboundDealMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedvariant {
		edges = append(edges, outbounddeal.EdgeVariant)
	}
	if m.clearedparent {
		edges = append(edges, outbounddeal.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, outbounddeal.EdgeChildren)
	}
	if m.clearedtransaction {
		edges = append(edges, outbounddeal.EdgeTransaction)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *OutboundDealMutation) EdgeCleared(name string) bool {
	switch name {
	case outbounddeal.EdgeVariant:
		return m.clearedvariant
	case outbounddeal.EdgeParent:
		return m.clearedparent
	case outbounddeal.EdgeChildren:
		return m.clearedchildren
	case outbounddeal.EdgeTransaction:
		return m.clearedtransaction
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *OutboundDealMutation) ClearEdge(name string) error {
	switch name {
	case outbounddeal.EdgeVariant:
		m.ClearVariant()
		return nil
	case outbounddeal.EdgeParent:
		m.ClearParent()
		return nil
	case outbounddeal.EdgeTransaction:
		m.ClearTransaction()
		return nil
	}
	return fmt.Errorf("unknown OutboundDeal unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *OutboundDealMutation) ResetEdge(name string) error {
	switch name {
	case outbounddeal.EdgeVariant:
		m.ResetVariant()
		return nil
	case outbounddeal.EdgeParent:
		m.ResetParent()
		return nil
	case outbounddeal.EdgeChildren:
		m.ResetChildren()
		return nil
	case outbounddeal.EdgeTransaction:
		m.ResetTransaction()
		return nil
	}
	return fmt.Errorf("unknown OutboundDeal edge %s", name)
}

// OutboundShippingMutation represents an operation that mutate the OutboundShippings
// nodes in the graph.
type OutboundShippingMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint64
	courier               *outboundshipping.Courier
	courier_tracking_code *string
	_type                 *outboundshipping.Type
	state                 *outboundshipping.State
	consignee             *string
	consignee_phone       *string
	address               *string
	postal_code           *uint
	addpostal_code        *uint
	cost                  *uint
	addcost               *uint
	clearedFields         map[string]struct{}
	transaction           *uint64
	clearedtransaction    bool
	done                  bool
	oldValue              func(context.Context) (*OutboundShipping, error)
	predicates            []predicate.OutboundShipping
}

var _ ent.Mutation = (*OutboundShippingMutation)(nil)

// outboundshippingOption allows to manage the mutation configuration using functional options.
type outboundshippingOption func(*OutboundShippingMutation)

// newOutboundShippingMutation creates new mutation for OutboundShipping.
func newOutboundShippingMutation(c config, op Op, opts ...outboundshippingOption) *OutboundShippingMutation {
	m := &OutboundShippingMutation{
		config:        c,
		op:            op,
		typ:           TypeOutboundShipping,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutboundShippingID sets the id field of the mutation.
func withOutboundShippingID(id uint64) outboundshippingOption {
	return func(m *OutboundShippingMutation) {
		var (
			err   error
			once  sync.Once
			value *OutboundShipping
		)
		m.oldValue = func(ctx context.Context) (*OutboundShipping, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutboundShipping.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutboundShipping sets the old OutboundShipping of the mutation.
func withOutboundShipping(node *OutboundShipping) outboundshippingOption {
	return func(m *OutboundShippingMutation) {
		m.oldValue = func(context.Context) (*OutboundShipping, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutboundShippingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutboundShippingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *OutboundShippingMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCourier sets the courier field.
func (m *OutboundShippingMutation) SetCourier(o outboundshipping.Courier) {
	m.courier = &o
}

// Courier returns the courier value in the mutation.
func (m *OutboundShippingMutation) Courier() (r outboundshipping.Courier, exists bool) {
	v := m.courier
	if v == nil {
		return
	}
	return *v, true
}

// OldCourier returns the old courier value of the OutboundShipping.
// If the OutboundShipping object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OutboundShippingMutation) OldCourier(ctx context.Context) (v outboundshipping.Courier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCourier is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCourier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourier: %w", err)
	}
	return oldValue.Courier, nil
}

// ResetCourier reset all changes of the "courier" field.
func (m *OutboundShippingMutation) ResetCourier() {
	m.courier = nil
}

// SetCourierTrackingCode sets the courier_tracking_code field.
func (m *OutboundShippingMutation) SetCourierTrackingCode(s string) {
	m.courier_tracking_code = &s
}

// CourierTrackingCode returns the courier_tracking_code value in the mutation.
func (m *OutboundShippingMutation) CourierTrackingCode() (r string, exists bool) {
	v := m.courier_tracking_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCourierTrackingCode returns the old courier_tracking_code value of the OutboundShipping.
// If the OutboundShipping object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OutboundShippingMutation) OldCourierTrackingCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCourierTrackingCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCourierTrackingCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourierTrackingCode: %w", err)
	}
	return oldValue.CourierTrackingCode, nil
}

// ResetCourierTrackingCode reset all changes of the "courier_tracking_code" field.
func (m *OutboundShippingMutation) ResetCourierTrackingCode() {
	m.courier_tracking_code = nil
}

// SetType sets the type field.
func (m *OutboundShippingMutation) SetType(o outboundshipping.Type) {
	m._type = &o
}

// GetType returns the type value in the mutation.
func (m *OutboundShippingMutation) GetType() (r outboundshipping.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the OutboundShipping.
// If the OutboundShipping object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OutboundShippingMutation) OldType(ctx context.Context) (v outboundshipping.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *OutboundShippingMutation) ResetType() {
	m._type = nil
}

// SetState sets the state field.
func (m *OutboundShippingMutation) SetState(o outboundshipping.State) {
	m.state = &o
}

// State returns the state value in the mutation.
func (m *OutboundShippingMutation) State() (r outboundshipping.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old state value of the OutboundShipping.
// If the OutboundShipping object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OutboundShippingMutation) OldState(ctx context.Context) (v outboundshipping.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldState is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState reset all changes of the "state" field.
func (m *OutboundShippingMutation) ResetState() {
	m.state = nil
}

// SetConsignee sets the consignee field.
func (m *OutboundShippingMutation) SetConsignee(s string) {
	m.consignee = &s
}

// Consignee returns the consignee value in the mutation.
func (m *OutboundShippingMutation) Consignee() (r string, exists bool) {
	v := m.consignee
	if v == nil {
		return
	}
	return *v, true
}

// OldConsignee returns the old consignee value of the OutboundShipping.
// If the OutboundShipping object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OutboundShippingMutation) OldConsignee(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConsignee is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConsignee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsignee: %w", err)
	}
	return oldValue.Consignee, nil
}

// ResetConsignee reset all changes of the "consignee" field.
func (m *OutboundShippingMutation) ResetConsignee() {
	m.consignee = nil
}

// SetConsigneePhone sets the consignee_phone field.
func (m *OutboundShippingMutation) SetConsigneePhone(s string) {
	m.consignee_phone = &s
}

// ConsigneePhone returns the consignee_phone value in the mutation.
func (m *OutboundShippingMutation) ConsigneePhone() (r string, exists bool) {
	v := m.consignee_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldConsigneePhone returns the old consignee_phone value of the OutboundShipping.
// If the OutboundShipping object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OutboundShippingMutation) OldConsigneePhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConsigneePhone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConsigneePhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsigneePhone: %w", err)
	}
	return oldValue.ConsigneePhone, nil
}

// ResetConsigneePhone reset all changes of the "consignee_phone" field.
func (m *OutboundShippingMutation) ResetConsigneePhone() {
	m.consignee_phone = nil
}

// SetAddress sets the address field.
func (m *OutboundShippingMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the address value in the mutation.
func (m *OutboundShippingMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old address value of the OutboundShipping.
// If the OutboundShipping object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OutboundShippingMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress reset all changes of the "address" field.
func (m *OutboundShippingMutation) ResetAddress() {
	m.address = nil
}

// SetPostalCode sets the postal_code field.
func (m *OutboundShippingMutation) SetPostalCode(u uint) {
	m.postal_code = &u
	m.addpostal_code = nil
}

// PostalCode returns the postal_code value in the mutation.
func (m *OutboundShippingMutation) PostalCode() (r uint, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old postal_code value of the OutboundShipping.
// If the OutboundShipping object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OutboundShippingMutation) OldPostalCode(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPostalCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// AddPostalCode adds u to postal_code.
func (m *OutboundShippingMutation) AddPostalCode(u uint) {
	if m.addpostal_code != nil {
		*m.addpostal_code += u
	} else {
		m.addpostal_code = &u
	}
}

// AddedPostalCode returns the value that was added to the postal_code field in this mutation.
func (m *OutboundShippingMutation) AddedPostalCode() (r uint, exists bool) {
	v := m.addpostal_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetPostalCode reset all changes of the "postal_code" field.
func (m *OutboundShippingMutation) ResetPostalCode() {
	m.postal_code = nil
	m.addpostal_code = nil
}

// SetCost sets the cost field.
func (m *OutboundShippingMutation) SetCost(u uint) {
	m.cost = &u
	m.addcost = nil
}

// Cost returns the cost value in the mutation.
func (m *OutboundShippingMutation) Cost() (r uint, exists bool) {
	v := m.cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCost returns the old cost value of the OutboundShipping.
// If the OutboundShipping object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OutboundShippingMutation) OldCost(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCost is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCost: %w", err)
	}
	return oldValue.Cost, nil
}

// AddCost adds u to cost.
func (m *OutboundShippingMutation) AddCost(u uint) {
	if m.addcost != nil {
		*m.addcost += u
	} else {
		m.addcost = &u
	}
}

// AddedCost returns the value that was added to the cost field in this mutation.
func (m *OutboundShippingMutation) AddedCost() (r uint, exists bool) {
	v := m.addcost
	if v == nil {
		return
	}
	return *v, true
}

// ResetCost reset all changes of the "cost" field.
func (m *OutboundShippingMutation) ResetCost() {
	m.cost = nil
	m.addcost = nil
}

// SetTransactionID sets the transaction edge to OutboundTransaction by id.
func (m *OutboundShippingMutation) SetTransactionID(id uint64) {
	m.transaction = &id
}

// ClearTransaction clears the transaction edge to OutboundTransaction.
func (m *OutboundShippingMutation) ClearTransaction() {
	m.clearedtransaction = true
}

// TransactionCleared returns if the edge transaction was cleared.
func (m *OutboundShippingMutation) TransactionCleared() bool {
	return m.clearedtransaction
}

// TransactionID returns the transaction id in the mutation.
func (m *OutboundShippingMutation) TransactionID() (id uint64, exists bool) {
	if m.transaction != nil {
		return *m.transaction, true
	}
	return
}

// TransactionIDs returns the transaction ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TransactionID instead. It exists only for internal usage by the builders.
func (m *OutboundShippingMutation) TransactionIDs() (ids []uint64) {
	if id := m.transaction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransaction reset all changes of the "transaction" edge.
func (m *OutboundShippingMutation) ResetTransaction() {
	m.transaction = nil
	m.clearedtransaction = false
}

// Op returns the operation name.
func (m *OutboundShippingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OutboundShipping).
func (m *OutboundShippingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *OutboundShippingMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.courier != nil {
		fields = append(fields, outboundshipping.FieldCourier)
	}
	if m.courier_tracking_code != nil {
		fields = append(fields, outboundshipping.FieldCourierTrackingCode)
	}
	if m._type != nil {
		fields = append(fields, outboundshipping.FieldType)
	}
	if m.state != nil {
		fields = append(fields, outboundshipping.FieldState)
	}
	if m.consignee != nil {
		fields = append(fields, outboundshipping.FieldConsignee)
	}
	if m.consignee_phone != nil {
		fields = append(fields, outboundshipping.FieldConsigneePhone)
	}
	if m.address != nil {
		fields = append(fields, outboundshipping.FieldAddress)
	}
	if m.postal_code != nil {
		fields = append(fields, outboundshipping.FieldPostalCode)
	}
	if m.cost != nil {
		fields = append(fields, outboundshipping.FieldCost)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *OutboundShippingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outboundshipping.FieldCourier:
		return m.Courier()
	case outboundshipping.FieldCourierTrackingCode:
		return m.CourierTrackingCode()
	case outboundshipping.FieldType:
		return m.GetType()
	case outboundshipping.FieldState:
		return m.State()
	case outboundshipping.FieldConsignee:
		return m.Consignee()
	case outboundshipping.FieldConsigneePhone:
		return m.ConsigneePhone()
	case outboundshipping.FieldAddress:
		return m.Address()
	case outboundshipping.FieldPostalCode:
		return m.PostalCode()
	case outboundshipping.FieldCost:
		return m.Cost()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *OutboundShippingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outboundshipping.FieldCourier:
		return m.OldCourier(ctx)
	case outboundshipping.FieldCourierTrackingCode:
		return m.OldCourierTrackingCode(ctx)
	case outboundshipping.FieldType:
		return m.OldType(ctx)
	case outboundshipping.FieldState:
		return m.OldState(ctx)
	case outboundshipping.FieldConsignee:
		return m.OldConsignee(ctx)
	case outboundshipping.FieldConsigneePhone:
		return m.OldConsigneePhone(ctx)
	case outboundshipping.FieldAddress:
		return m.OldAddress(ctx)
	case outboundshipping.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case outboundshipping.FieldCost:
		return m.OldCost(ctx)
	}
	return nil, fmt.Errorf("unknown OutboundShipping field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OutboundShippingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outboundshipping.FieldCourier:
		v, ok := value.(outboundshipping.Courier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourier(v)
		return nil
	case outboundshipping.FieldCourierTrackingCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourierTrackingCode(v)
		return nil
	case outboundshipping.FieldType:
		v, ok := value.(outboundshipping.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case outboundshipping.FieldState:
		v, ok := value.(outboundshipping.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case outboundshipping.FieldConsignee:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsignee(v)
		return nil
	case outboundshipping.FieldConsigneePhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsigneePhone(v)
		return nil
	case outboundshipping.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case outboundshipping.FieldPostalCode:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case outboundshipping.FieldCost:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCost(v)
		return nil
	}
	return fmt.Errorf("unknown OutboundShipping field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *OutboundShippingMutation) AddedFields() []string {
	var fields []string
	if m.addpostal_code != nil {
		fields = append(fields, outboundshipping.FieldPostalCode)
	}
	if m.addcost != nil {
		fields = append(fields, outboundshipping.FieldCost)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *OutboundShippingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case outboundshipping.FieldPostalCode:
		return m.AddedPostalCode()
	case outboundshipping.FieldCost:
		return m.AddedCost()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OutboundShippingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case outboundshipping.FieldPostalCode:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostalCode(v)
		return nil
	case outboundshipping.FieldCost:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCost(v)
		return nil
	}
	return fmt.Errorf("unknown OutboundShipping numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *OutboundShippingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *OutboundShippingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutboundShippingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OutboundShipping nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *OutboundShippingMutation) ResetField(name string) error {
	switch name {
	case outboundshipping.FieldCourier:
		m.ResetCourier()
		return nil
	case outboundshipping.FieldCourierTrackingCode:
		m.ResetCourierTrackingCode()
		return nil
	case outboundshipping.FieldType:
		m.ResetType()
		return nil
	case outboundshipping.FieldState:
		m.ResetState()
		return nil
	case outboundshipping.FieldConsignee:
		m.ResetConsignee()
		return nil
	case outboundshipping.FieldConsigneePhone:
		m.ResetConsigneePhone()
		return nil
	case outboundshipping.FieldAddress:
		m.ResetAddress()
		return nil
	case outboundshipping.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case outboundshipping.FieldCost:
		m.ResetCost()
		return nil
	}
	return fmt.Errorf("unknown OutboundShipping field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *OutboundShippingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.transaction != nil {
		edges = append(edges, outboundshipping.EdgeTransaction)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *OutboundShippingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case outboundshipping.EdgeTransaction:
		if id := m.transaction; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *OutboundShippingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *OutboundShippingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *OutboundShippingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtransaction {
		edges = append(edges, outboundshipping.EdgeTransaction)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *OutboundShippingMutation) EdgeCleared(name string) bool {
	switch name {
	case outboundshipping.EdgeTransaction:
		return m.clearedtransaction
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *OutboundShippingMutation) ClearEdge(name string) error {
	switch name {
	case outboundshipping.EdgeTransaction:
		m.ClearTransaction()
		return nil
	}
	return fmt.Errorf("unknown OutboundShipping unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *OutboundShippingMutation) ResetEdge(name string) error {
	switch name {
	case outboundshipping.EdgeTransaction:
		m.ResetTransaction()
		return nil
	}
	return fmt.Errorf("unknown OutboundShipping edge %s", name)
}

// OutboundTransactionMutation represents an operation that mutate the OutboundTransactions
// nodes in the graph.
type OutboundTransactionMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	channel         *outboundtransaction.Channel
	invoice         *schema.OutboundTransactionInvoice
	benefit         *schema.OutboundTransactionBenefit
	cost            *schema.OutboundTransactionCost
	amount          *uint
	addamount       *uint
	clearedFields   map[string]struct{}
	deals           map[uint64]struct{}
	removeddeals    map[uint64]struct{}
	cleareddeals    bool
	shipping        *uint64
	clearedshipping bool
	done            bool
	oldValue        func(context.Context) (*OutboundTransaction, error)
	predicates      []predicate.OutboundTransaction
}

var _ ent.Mutation = (*OutboundTransactionMutation)(nil)

// outboundtransactionOption allows to manage the mutation configuration using functional options.
type outboundtransactionOption func(*OutboundTransactionMutation)

// newOutboundTransactionMutation creates new mutation for OutboundTransaction.
func newOutboundTransactionMutation(c config, op Op, opts ...outboundtransactionOption) *OutboundTransactionMutation {
	m := &OutboundTransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeOutboundTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutboundTransactionID sets the id field of the mutation.
func withOutboundTransactionID(id uint64) outboundtransactionOption {
	return func(m *OutboundTransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *OutboundTransaction
		)
		m.oldValue = func(ctx context.Context) (*OutboundTransaction, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutboundTransaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutboundTransaction sets the old OutboundTransaction of the mutation.
func withOutboundTransaction(node *OutboundTransaction) outboundtransactionOption {
	return func(m *OutboundTransactionMutation) {
		m.oldValue = func(context.Context) (*OutboundTransaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutboundTransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutboundTransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *OutboundTransactionMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetChannel sets the channel field.
func (m *OutboundTransactionMutation) SetChannel(o outboundtransaction.Channel) {
	m.channel = &o
}

// Channel returns the channel value in the mutation.
func (m *OutboundTransactionMutation) Channel() (r outboundtransaction.Channel, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old channel value of the OutboundTransaction.
// If the OutboundTransaction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OutboundTransactionMutation) OldChannel(ctx context.Context) (v outboundtransaction.Channel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldChannel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel reset all changes of the "channel" field.
func (m *OutboundTransactionMutation) ResetChannel() {
	m.channel = nil
}

// SetInvoice sets the invoice field.
func (m *OutboundTransactionMutation) SetInvoice(sti schema.OutboundTransactionInvoice) {
	m.invoice = &sti
}

// Invoice returns the invoice value in the mutation.
func (m *OutboundTransactionMutation) Invoice() (r schema.OutboundTransactionInvoice, exists bool) {
	v := m.invoice
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoice returns the old invoice value of the OutboundTransaction.
// If the OutboundTransaction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OutboundTransactionMutation) OldInvoice(ctx context.Context) (v schema.OutboundTransactionInvoice, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInvoice is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInvoice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoice: %w", err)
	}
	return oldValue.Invoice, nil
}

// ResetInvoice reset all changes of the "invoice" field.
func (m *OutboundTransactionMutation) ResetInvoice() {
	m.invoice = nil
}

// SetBenefit sets the benefit field.
func (m *OutboundTransactionMutation) SetBenefit(stb schema.OutboundTransactionBenefit) {
	m.benefit = &stb
}

// Benefit returns the benefit value in the mutation.
func (m *OutboundTransactionMutation) Benefit() (r schema.OutboundTransactionBenefit, exists bool) {
	v := m.benefit
	if v == nil {
		return
	}
	return *v, true
}

// OldBenefit returns the old benefit value of the OutboundTransaction.
// If the OutboundTransaction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OutboundTransactionMutation) OldBenefit(ctx context.Context) (v schema.OutboundTransactionBenefit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBenefit is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBenefit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBenefit: %w", err)
	}
	return oldValue.Benefit, nil
}

// ResetBenefit reset all changes of the "benefit" field.
func (m *OutboundTransactionMutation) ResetBenefit() {
	m.benefit = nil
}

// SetCost sets the cost field.
func (m *OutboundTransactionMutation) SetCost(stc schema.OutboundTransactionCost) {
	m.cost = &stc
}

// Cost returns the cost value in the mutation.
func (m *OutboundTransactionMutation) Cost() (r schema.OutboundTransactionCost, exists bool) {
	v := m.cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCost returns the old cost value of the OutboundTransaction.
// If the OutboundTransaction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OutboundTransactionMutation) OldCost(ctx context.Context) (v schema.OutboundTransactionCost, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCost is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCost: %w", err)
	}
	return oldValue.Cost, nil
}

// ResetCost reset all changes of the "cost" field.
func (m *OutboundTransactionMutation) ResetCost() {
	m.cost = nil
}

// SetAmount sets the amount field.
func (m *OutboundTransactionMutation) SetAmount(u uint) {
	m.amount = &u
	m.addamount = nil
}

// Amount returns the amount value in the mutation.
func (m *OutboundTransactionMutation) Amount() (r uint, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old amount value of the OutboundTransaction.
// If the OutboundTransaction object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OutboundTransactionMutation) OldAmount(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds u to amount.
func (m *OutboundTransactionMutation) AddAmount(u uint) {
	if m.addamount != nil {
		*m.addamount += u
	} else {
		m.addamount = &u
	}
}

// AddedAmount returns the value that was added to the amount field in this mutation.
func (m *OutboundTransactionMutation) AddedAmount() (r uint, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount reset all changes of the "amount" field.
func (m *OutboundTransactionMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// AddDealIDs adds the deals edge to OutboundDeal by ids.
func (m *OutboundTransactionMutation) AddDealIDs(ids ...uint64) {
	if m.deals == nil {
		m.deals = make(map[uint64]struct{})
	}
	for i := range ids {
		m.deals[ids[i]] = struct{}{}
	}
}

// ClearDeals clears the deals edge to OutboundDeal.
func (m *OutboundTransactionMutation) ClearDeals() {
	m.cleareddeals = true
}

// DealsCleared returns if the edge deals was cleared.
func (m *OutboundTransactionMutation) DealsCleared() bool {
	return m.cleareddeals
}

// RemoveDealIDs removes the deals edge to OutboundDeal by ids.
func (m *OutboundTransactionMutation) RemoveDealIDs(ids ...uint64) {
	if m.removeddeals == nil {
		m.removeddeals = make(map[uint64]struct{})
	}
	for i := range ids {
		m.removeddeals[ids[i]] = struct{}{}
	}
}

// RemovedDeals returns the removed ids of deals.
func (m *OutboundTransactionMutation) RemovedDealsIDs() (ids []uint64) {
	for id := range m.removeddeals {
		ids = append(ids, id)
	}
	return
}

// DealsIDs returns the deals ids in the mutation.
func (m *OutboundTransactionMutation) DealsIDs() (ids []uint64) {
	for id := range m.deals {
		ids = append(ids, id)
	}
	return
}

// ResetDeals reset all changes of the "deals" edge.
func (m *OutboundTransactionMutation) ResetDeals() {
	m.deals = nil
	m.cleareddeals = false
	m.removeddeals = nil
}

// SetShippingID sets the shipping edge to OutboundShipping by id.
func (m *OutboundTransactionMutation) SetShippingID(id uint64) {
	m.shipping = &id
}

// ClearShipping clears the shipping edge to OutboundShipping.
func (m *OutboundTransactionMutation) ClearShipping() {
	m.clearedshipping = true
}

// ShippingCleared returns if the edge shipping was cleared.
func (m *OutboundTransactionMutation) ShippingCleared() bool {
	return m.clearedshipping
}

// ShippingID returns the shipping id in the mutation.
func (m *OutboundTransactionMutation) ShippingID() (id uint64, exists bool) {
	if m.shipping != nil {
		return *m.shipping, true
	}
	return
}

// ShippingIDs returns the shipping ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ShippingID instead. It exists only for internal usage by the builders.
func (m *OutboundTransactionMutation) ShippingIDs() (ids []uint64) {
	if id := m.shipping; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipping reset all changes of the "shipping" edge.
func (m *OutboundTransactionMutation) ResetShipping() {
	m.shipping = nil
	m.clearedshipping = false
}

// Op returns the operation name.
func (m *OutboundTransactionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OutboundTransaction).
func (m *OutboundTransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *OutboundTransactionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.channel != nil {
		fields = append(fields, outboundtransaction.FieldChannel)
	}
	if m.invoice != nil {
		fields = append(fields, outboundtransaction.FieldInvoice)
	}
	if m.benefit != nil {
		fields = append(fields, outboundtransaction.FieldBenefit)
	}
	if m.cost != nil {
		fields = append(fields, outboundtransaction.FieldCost)
	}
	if m.amount != nil {
		fields = append(fields, outboundtransaction.FieldAmount)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *OutboundTransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outboundtransaction.FieldChannel:
		return m.Channel()
	case outboundtransaction.FieldInvoice:
		return m.Invoice()
	case outboundtransaction.FieldBenefit:
		return m.Benefit()
	case outboundtransaction.FieldCost:
		return m.Cost()
	case outboundtransaction.FieldAmount:
		return m.Amount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *OutboundTransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outboundtransaction.FieldChannel:
		return m.OldChannel(ctx)
	case outboundtransaction.FieldInvoice:
		return m.OldInvoice(ctx)
	case outboundtransaction.FieldBenefit:
		return m.OldBenefit(ctx)
	case outboundtransaction.FieldCost:
		return m.OldCost(ctx)
	case outboundtransaction.FieldAmount:
		return m.OldAmount(ctx)
	}
	return nil, fmt.Errorf("unknown OutboundTransaction field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OutboundTransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outboundtransaction.FieldChannel:
		v, ok := value.(outboundtransaction.Channel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case outboundtransaction.FieldInvoice:
		v, ok := value.(schema.OutboundTransactionInvoice)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoice(v)
		return nil
	case outboundtransaction.FieldBenefit:
		v, ok := value.(schema.OutboundTransactionBenefit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBenefit(v)
		return nil
	case outboundtransaction.FieldCost:
		v, ok := value.(schema.OutboundTransactionCost)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCost(v)
		return nil
	case outboundtransaction.FieldAmount:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	}
	return fmt.Errorf("unknown OutboundTransaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *OutboundTransactionMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, outboundtransaction.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *OutboundTransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case outboundtransaction.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OutboundTransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case outboundtransaction.FieldAmount:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown OutboundTransaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *OutboundTransactionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *OutboundTransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutboundTransactionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OutboundTransaction nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *OutboundTransactionMutation) ResetField(name string) error {
	switch name {
	case outboundtransaction.FieldChannel:
		m.ResetChannel()
		return nil
	case outboundtransaction.FieldInvoice:
		m.ResetInvoice()
		return nil
	case outboundtransaction.FieldBenefit:
		m.ResetBenefit()
		return nil
	case outboundtransaction.FieldCost:
		m.ResetCost()
		return nil
	case outboundtransaction.FieldAmount:
		m.ResetAmount()
		return nil
	}
	return fmt.Errorf("unknown OutboundTransaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *OutboundTransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.deals != nil {
		edges = append(edges, outboundtransaction.EdgeDeals)
	}
	if m.shipping != nil {
		edges = append(edges, outboundtransaction.EdgeShipping)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *OutboundTransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case outboundtransaction.EdgeDeals:
		ids := make([]ent.Value, 0, len(m.deals))
		for id := range m.deals {
			ids = append(ids, id)
		}
		return ids
	case outboundtransaction.EdgeShipping:
		if id := m.shipping; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *OutboundTransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddeals != nil {
		edges = append(edges, outboundtransaction.EdgeDeals)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *OutboundTransactionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case outboundtransaction.EdgeDeals:
		ids := make([]ent.Value, 0, len(m.removeddeals))
		for id := range m.removeddeals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *OutboundTransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddeals {
		edges = append(edges, outboundtransaction.EdgeDeals)
	}
	if m.clearedshipping {
		edges = append(edges, outboundtransaction.EdgeShipping)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *OutboundTransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case outboundtransaction.EdgeDeals:
		return m.cleareddeals
	case outboundtransaction.EdgeShipping:
		return m.clearedshipping
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *OutboundTransactionMutation) ClearEdge(name string) error {
	switch name {
	case outboundtransaction.EdgeShipping:
		m.ClearShipping()
		return nil
	}
	return fmt.Errorf("unknown OutboundTransaction unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *OutboundTransactionMutation) ResetEdge(name string) error {
	switch name {
	case outboundtransaction.EdgeDeals:
		m.ResetDeals()
		return nil
	case outboundtransaction.EdgeShipping:
		m.ResetShipping()
		return nil
	}
	return fmt.Errorf("unknown OutboundTransaction edge %s", name)
}

// ProductMutation represents an operation that mutate the Products
// nodes in the graph.
type ProductMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	sku             *string
	name            *string
	descriptions    *[]schema.ProductDescription
	images          *schema.ProductImages
	marketplaces    *schema.ProductMarketplaces
	clearedFields   map[string]struct{}
	variants        map[uint64]struct{}
	removedvariants map[uint64]struct{}
	clearedvariants bool
	brand           *uint64
	clearedbrand    bool
	done            bool
	oldValue        func(context.Context) (*Product, error)
	predicates      []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows to manage the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for Product.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the id field of the mutation.
func withProductID(id uint64) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ProductMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSku sets the sku field.
func (m *ProductMutation) SetSku(s string) {
	m.sku = &s
}

// Sku returns the sku value in the mutation.
func (m *ProductMutation) Sku() (r string, exists bool) {
	v := m.sku
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old sku value of the Product.
// If the Product object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProductMutation) OldSku(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSku is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ResetSku reset all changes of the "sku" field.
func (m *ProductMutation) ResetSku() {
	m.sku = nil
}

// SetName sets the name field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Product.
// If the Product object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
}

// SetDescriptions sets the descriptions field.
func (m *ProductMutation) SetDescriptions(sd []schema.ProductDescription) {
	m.descriptions = &sd
}

// Descriptions returns the descriptions value in the mutation.
func (m *ProductMutation) Descriptions() (r []schema.ProductDescription, exists bool) {
	v := m.descriptions
	if v == nil {
		return
	}
	return *v, true
}

// OldDescriptions returns the old descriptions value of the Product.
// If the Product object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProductMutation) OldDescriptions(ctx context.Context) (v []schema.ProductDescription, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescriptions is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescriptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescriptions: %w", err)
	}
	return oldValue.Descriptions, nil
}

// ResetDescriptions reset all changes of the "descriptions" field.
func (m *ProductMutation) ResetDescriptions() {
	m.descriptions = nil
}

// SetImages sets the images field.
func (m *ProductMutation) SetImages(si schema.ProductImages) {
	m.images = &si
}

// Images returns the images value in the mutation.
func (m *ProductMutation) Images() (r schema.ProductImages, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old images value of the Product.
// If the Product object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProductMutation) OldImages(ctx context.Context) (v schema.ProductImages, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImages is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// ResetImages reset all changes of the "images" field.
func (m *ProductMutation) ResetImages() {
	m.images = nil
}

// SetMarketplaces sets the marketplaces field.
func (m *ProductMutation) SetMarketplaces(sm schema.ProductMarketplaces) {
	m.marketplaces = &sm
}

// Marketplaces returns the marketplaces value in the mutation.
func (m *ProductMutation) Marketplaces() (r schema.ProductMarketplaces, exists bool) {
	v := m.marketplaces
	if v == nil {
		return
	}
	return *v, true
}

// OldMarketplaces returns the old marketplaces value of the Product.
// If the Product object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProductMutation) OldMarketplaces(ctx context.Context) (v schema.ProductMarketplaces, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMarketplaces is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMarketplaces requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarketplaces: %w", err)
	}
	return oldValue.Marketplaces, nil
}

// ResetMarketplaces reset all changes of the "marketplaces" field.
func (m *ProductMutation) ResetMarketplaces() {
	m.marketplaces = nil
}

// AddVariantIDs adds the variants edge to Variant by ids.
func (m *ProductMutation) AddVariantIDs(ids ...uint64) {
	if m.variants == nil {
		m.variants = make(map[uint64]struct{})
	}
	for i := range ids {
		m.variants[ids[i]] = struct{}{}
	}
}

// ClearVariants clears the variants edge to Variant.
func (m *ProductMutation) ClearVariants() {
	m.clearedvariants = true
}

// VariantsCleared returns if the edge variants was cleared.
func (m *ProductMutation) VariantsCleared() bool {
	return m.clearedvariants
}

// RemoveVariantIDs removes the variants edge to Variant by ids.
func (m *ProductMutation) RemoveVariantIDs(ids ...uint64) {
	if m.removedvariants == nil {
		m.removedvariants = make(map[uint64]struct{})
	}
	for i := range ids {
		m.removedvariants[ids[i]] = struct{}{}
	}
}

// RemovedVariants returns the removed ids of variants.
func (m *ProductMutation) RemovedVariantsIDs() (ids []uint64) {
	for id := range m.removedvariants {
		ids = append(ids, id)
	}
	return
}

// VariantsIDs returns the variants ids in the mutation.
func (m *ProductMutation) VariantsIDs() (ids []uint64) {
	for id := range m.variants {
		ids = append(ids, id)
	}
	return
}

// ResetVariants reset all changes of the "variants" edge.
func (m *ProductMutation) ResetVariants() {
	m.variants = nil
	m.clearedvariants = false
	m.removedvariants = nil
}

// SetBrandID sets the brand edge to Brand by id.
func (m *ProductMutation) SetBrandID(id uint64) {
	m.brand = &id
}

// ClearBrand clears the brand edge to Brand.
func (m *ProductMutation) ClearBrand() {
	m.clearedbrand = true
}

// BrandCleared returns if the edge brand was cleared.
func (m *ProductMutation) BrandCleared() bool {
	return m.clearedbrand
}

// BrandID returns the brand id in the mutation.
func (m *ProductMutation) BrandID() (id uint64, exists bool) {
	if m.brand != nil {
		return *m.brand, true
	}
	return
}

// BrandIDs returns the brand ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BrandID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) BrandIDs() (ids []uint64) {
	if id := m.brand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBrand reset all changes of the "brand" edge.
func (m *ProductMutation) ResetBrand() {
	m.brand = nil
	m.clearedbrand = false
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.sku != nil {
		fields = append(fields, product.FieldSku)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.descriptions != nil {
		fields = append(fields, product.FieldDescriptions)
	}
	if m.images != nil {
		fields = append(fields, product.FieldImages)
	}
	if m.marketplaces != nil {
		fields = append(fields, product.FieldMarketplaces)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldSku:
		return m.Sku()
	case product.FieldName:
		return m.Name()
	case product.FieldDescriptions:
		return m.Descriptions()
	case product.FieldImages:
		return m.Images()
	case product.FieldMarketplaces:
		return m.Marketplaces()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldSku:
		return m.OldSku(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldDescriptions:
		return m.OldDescriptions(ctx)
	case product.FieldImages:
		return m.OldImages(ctx)
	case product.FieldMarketplaces:
		return m.OldMarketplaces(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldDescriptions:
		v, ok := value.([]schema.ProductDescription)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescriptions(v)
		return nil
	case product.FieldImages:
		v, ok := value.(schema.ProductImages)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case product.FieldMarketplaces:
		v, ok := value.(schema.ProductMarketplaces)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarketplaces(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ProductMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ProductMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldSku:
		m.ResetSku()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldDescriptions:
		m.ResetDescriptions()
		return nil
	case product.FieldImages:
		m.ResetImages()
		return nil
	case product.FieldMarketplaces:
		m.ResetMarketplaces()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.variants != nil {
		edges = append(edges, product.EdgeVariants)
	}
	if m.brand != nil {
		edges = append(edges, product.EdgeBrand)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeVariants:
		ids := make([]ent.Value, 0, len(m.variants))
		for id := range m.variants {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeBrand:
		if id := m.brand; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedvariants != nil {
		edges = append(edges, product.EdgeVariants)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeVariants:
		ids := make([]ent.Value, 0, len(m.removedvariants))
		for id := range m.removedvariants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedvariants {
		edges = append(edges, product.EdgeVariants)
	}
	if m.clearedbrand {
		edges = append(edges, product.EdgeBrand)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeVariants:
		return m.clearedvariants
	case product.EdgeBrand:
		return m.clearedbrand
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeBrand:
		m.ClearBrand()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeVariants:
		m.ResetVariants()
		return nil
	case product.EdgeBrand:
		m.ResetBrand()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// VariantMutation represents an operation that mutate the Variants
// nodes in the graph.
type VariantMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint64
	images                *[]string
	stock                 *uint8
	addstock              *uint8
	price                 *uint
	addprice              *uint
	clearedFields         map[string]struct{}
	parent                *uint64
	clearedparent         bool
	children              map[uint64]struct{}
	removedchildren       map[uint64]struct{}
	clearedchildren       bool
	variation             *uint64
	clearedvariation      bool
	product               *uint64
	clearedproduct        bool
	outbound_deals        map[uint64]struct{}
	removedoutbound_deals map[uint64]struct{}
	clearedoutbound_deals bool
	done                  bool
	oldValue              func(context.Context) (*Variant, error)
	predicates            []predicate.Variant
}

var _ ent.Mutation = (*VariantMutation)(nil)

// variantOption allows to manage the mutation configuration using functional options.
type variantOption func(*VariantMutation)

// newVariantMutation creates new mutation for Variant.
func newVariantMutation(c config, op Op, opts ...variantOption) *VariantMutation {
	m := &VariantMutation{
		config:        c,
		op:            op,
		typ:           TypeVariant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVariantID sets the id field of the mutation.
func withVariantID(id uint64) variantOption {
	return func(m *VariantMutation) {
		var (
			err   error
			once  sync.Once
			value *Variant
		)
		m.oldValue = func(ctx context.Context) (*Variant, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Variant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVariant sets the old Variant of the mutation.
func withVariant(node *Variant) variantOption {
	return func(m *VariantMutation) {
		m.oldValue = func(context.Context) (*Variant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VariantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VariantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *VariantMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetImages sets the images field.
func (m *VariantMutation) SetImages(s []string) {
	m.images = &s
}

// Images returns the images value in the mutation.
func (m *VariantMutation) Images() (r []string, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old images value of the Variant.
// If the Variant object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VariantMutation) OldImages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImages is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// ClearImages clears the value of images.
func (m *VariantMutation) ClearImages() {
	m.images = nil
	m.clearedFields[variant.FieldImages] = struct{}{}
}

// ImagesCleared returns if the field images was cleared in this mutation.
func (m *VariantMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[variant.FieldImages]
	return ok
}

// ResetImages reset all changes of the "images" field.
func (m *VariantMutation) ResetImages() {
	m.images = nil
	delete(m.clearedFields, variant.FieldImages)
}

// SetStock sets the stock field.
func (m *VariantMutation) SetStock(u uint8) {
	m.stock = &u
	m.addstock = nil
}

// Stock returns the stock value in the mutation.
func (m *VariantMutation) Stock() (r uint8, exists bool) {
	v := m.stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStock returns the old stock value of the Variant.
// If the Variant object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VariantMutation) OldStock(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStock is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStock: %w", err)
	}
	return oldValue.Stock, nil
}

// AddStock adds u to stock.
func (m *VariantMutation) AddStock(u uint8) {
	if m.addstock != nil {
		*m.addstock += u
	} else {
		m.addstock = &u
	}
}

// AddedStock returns the value that was added to the stock field in this mutation.
func (m *VariantMutation) AddedStock() (r uint8, exists bool) {
	v := m.addstock
	if v == nil {
		return
	}
	return *v, true
}

// ResetStock reset all changes of the "stock" field.
func (m *VariantMutation) ResetStock() {
	m.stock = nil
	m.addstock = nil
}

// SetPrice sets the price field.
func (m *VariantMutation) SetPrice(u uint) {
	m.price = &u
	m.addprice = nil
}

// Price returns the price value in the mutation.
func (m *VariantMutation) Price() (r uint, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old price value of the Variant.
// If the Variant object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VariantMutation) OldPrice(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds u to price.
func (m *VariantMutation) AddPrice(u uint) {
	if m.addprice != nil {
		*m.addprice += u
	} else {
		m.addprice = &u
	}
}

// AddedPrice returns the value that was added to the price field in this mutation.
func (m *VariantMutation) AddedPrice() (r uint, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice reset all changes of the "price" field.
func (m *VariantMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetParentID sets the parent edge to Variant by id.
func (m *VariantMutation) SetParentID(id uint64) {
	m.parent = &id
}

// ClearParent clears the parent edge to Variant.
func (m *VariantMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared returns if the edge parent was cleared.
func (m *VariantMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the parent id in the mutation.
func (m *VariantMutation) ParentID() (id uint64, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the parent ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *VariantMutation) ParentIDs() (ids []uint64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent reset all changes of the "parent" edge.
func (m *VariantMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the children edge to Variant by ids.
func (m *VariantMutation) AddChildIDs(ids ...uint64) {
	if m.children == nil {
		m.children = make(map[uint64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the children edge to Variant.
func (m *VariantMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared returns if the edge children was cleared.
func (m *VariantMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the children edge to Variant by ids.
func (m *VariantMutation) RemoveChildIDs(ids ...uint64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uint64]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed ids of children.
func (m *VariantMutation) RemovedChildrenIDs() (ids []uint64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the children ids in the mutation.
func (m *VariantMutation) ChildrenIDs() (ids []uint64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren reset all changes of the "children" edge.
func (m *VariantMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// SetVariationID sets the variation edge to Variation by id.
func (m *VariantMutation) SetVariationID(id uint64) {
	m.variation = &id
}

// ClearVariation clears the variation edge to Variation.
func (m *VariantMutation) ClearVariation() {
	m.clearedvariation = true
}

// VariationCleared returns if the edge variation was cleared.
func (m *VariantMutation) VariationCleared() bool {
	return m.clearedvariation
}

// VariationID returns the variation id in the mutation.
func (m *VariantMutation) VariationID() (id uint64, exists bool) {
	if m.variation != nil {
		return *m.variation, true
	}
	return
}

// VariationIDs returns the variation ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// VariationID instead. It exists only for internal usage by the builders.
func (m *VariantMutation) VariationIDs() (ids []uint64) {
	if id := m.variation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVariation reset all changes of the "variation" edge.
func (m *VariantMutation) ResetVariation() {
	m.variation = nil
	m.clearedvariation = false
}

// SetProductID sets the product edge to Product by id.
func (m *VariantMutation) SetProductID(id uint64) {
	m.product = &id
}

// ClearProduct clears the product edge to Product.
func (m *VariantMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared returns if the edge product was cleared.
func (m *VariantMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the product id in the mutation.
func (m *VariantMutation) ProductID() (id uint64, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the product ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *VariantMutation) ProductIDs() (ids []uint64) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct reset all changes of the "product" edge.
func (m *VariantMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// AddOutboundDealIDs adds the outbound_deals edge to OutboundDeal by ids.
func (m *VariantMutation) AddOutboundDealIDs(ids ...uint64) {
	if m.outbound_deals == nil {
		m.outbound_deals = make(map[uint64]struct{})
	}
	for i := range ids {
		m.outbound_deals[ids[i]] = struct{}{}
	}
}

// ClearOutboundDeals clears the outbound_deals edge to OutboundDeal.
func (m *VariantMutation) ClearOutboundDeals() {
	m.clearedoutbound_deals = true
}

// OutboundDealsCleared returns if the edge outbound_deals was cleared.
func (m *VariantMutation) OutboundDealsCleared() bool {
	return m.clearedoutbound_deals
}

// RemoveOutboundDealIDs removes the outbound_deals edge to OutboundDeal by ids.
func (m *VariantMutation) RemoveOutboundDealIDs(ids ...uint64) {
	if m.removedoutbound_deals == nil {
		m.removedoutbound_deals = make(map[uint64]struct{})
	}
	for i := range ids {
		m.removedoutbound_deals[ids[i]] = struct{}{}
	}
}

// RemovedOutboundDeals returns the removed ids of outbound_deals.
func (m *VariantMutation) RemovedOutboundDealsIDs() (ids []uint64) {
	for id := range m.removedoutbound_deals {
		ids = append(ids, id)
	}
	return
}

// OutboundDealsIDs returns the outbound_deals ids in the mutation.
func (m *VariantMutation) OutboundDealsIDs() (ids []uint64) {
	for id := range m.outbound_deals {
		ids = append(ids, id)
	}
	return
}

// ResetOutboundDeals reset all changes of the "outbound_deals" edge.
func (m *VariantMutation) ResetOutboundDeals() {
	m.outbound_deals = nil
	m.clearedoutbound_deals = false
	m.removedoutbound_deals = nil
}

// Op returns the operation name.
func (m *VariantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Variant).
func (m *VariantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *VariantMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.images != nil {
		fields = append(fields, variant.FieldImages)
	}
	if m.stock != nil {
		fields = append(fields, variant.FieldStock)
	}
	if m.price != nil {
		fields = append(fields, variant.FieldPrice)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *VariantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case variant.FieldImages:
		return m.Images()
	case variant.FieldStock:
		return m.Stock()
	case variant.FieldPrice:
		return m.Price()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *VariantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case variant.FieldImages:
		return m.OldImages(ctx)
	case variant.FieldStock:
		return m.OldStock(ctx)
	case variant.FieldPrice:
		return m.OldPrice(ctx)
	}
	return nil, fmt.Errorf("unknown Variant field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *VariantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case variant.FieldImages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case variant.FieldStock:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStock(v)
		return nil
	case variant.FieldPrice:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Variant field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *VariantMutation) AddedFields() []string {
	var fields []string
	if m.addstock != nil {
		fields = append(fields, variant.FieldStock)
	}
	if m.addprice != nil {
		fields = append(fields, variant.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *VariantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case variant.FieldStock:
		return m.AddedStock()
	case variant.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *VariantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case variant.FieldStock:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStock(v)
		return nil
	case variant.FieldPrice:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Variant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *VariantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(variant.FieldImages) {
		fields = append(fields, variant.FieldImages)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *VariantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *VariantMutation) ClearField(name string) error {
	switch name {
	case variant.FieldImages:
		m.ClearImages()
		return nil
	}
	return fmt.Errorf("unknown Variant nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *VariantMutation) ResetField(name string) error {
	switch name {
	case variant.FieldImages:
		m.ResetImages()
		return nil
	case variant.FieldStock:
		m.ResetStock()
		return nil
	case variant.FieldPrice:
		m.ResetPrice()
		return nil
	}
	return fmt.Errorf("unknown Variant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *VariantMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.parent != nil {
		edges = append(edges, variant.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, variant.EdgeChildren)
	}
	if m.variation != nil {
		edges = append(edges, variant.EdgeVariation)
	}
	if m.product != nil {
		edges = append(edges, variant.EdgeProduct)
	}
	if m.outbound_deals != nil {
		edges = append(edges, variant.EdgeOutboundDeals)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *VariantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case variant.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case variant.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case variant.EdgeVariation:
		if id := m.variation; id != nil {
			return []ent.Value{*id}
		}
	case variant.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case variant.EdgeOutboundDeals:
		ids := make([]ent.Value, 0, len(m.outbound_deals))
		for id := range m.outbound_deals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *VariantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedchildren != nil {
		edges = append(edges, variant.EdgeChildren)
	}
	if m.removedoutbound_deals != nil {
		edges = append(edges, variant.EdgeOutboundDeals)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *VariantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case variant.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case variant.EdgeOutboundDeals:
		ids := make([]ent.Value, 0, len(m.removedoutbound_deals))
		for id := range m.removedoutbound_deals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *VariantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedparent {
		edges = append(edges, variant.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, variant.EdgeChildren)
	}
	if m.clearedvariation {
		edges = append(edges, variant.EdgeVariation)
	}
	if m.clearedproduct {
		edges = append(edges, variant.EdgeProduct)
	}
	if m.clearedoutbound_deals {
		edges = append(edges, variant.EdgeOutboundDeals)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *VariantMutation) EdgeCleared(name string) bool {
	switch name {
	case variant.EdgeParent:
		return m.clearedparent
	case variant.EdgeChildren:
		return m.clearedchildren
	case variant.EdgeVariation:
		return m.clearedvariation
	case variant.EdgeProduct:
		return m.clearedproduct
	case variant.EdgeOutboundDeals:
		return m.clearedoutbound_deals
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *VariantMutation) ClearEdge(name string) error {
	switch name {
	case variant.EdgeParent:
		m.ClearParent()
		return nil
	case variant.EdgeVariation:
		m.ClearVariation()
		return nil
	case variant.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown Variant unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *VariantMutation) ResetEdge(name string) error {
	switch name {
	case variant.EdgeParent:
		m.ResetParent()
		return nil
	case variant.EdgeChildren:
		m.ResetChildren()
		return nil
	case variant.EdgeVariation:
		m.ResetVariation()
		return nil
	case variant.EdgeProduct:
		m.ResetProduct()
		return nil
	case variant.EdgeOutboundDeals:
		m.ResetOutboundDeals()
		return nil
	}
	return fmt.Errorf("unknown Variant edge %s", name)
}

// VariationMutation represents an operation that mutate the Variations
// nodes in the graph.
type VariationMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	_type           *string
	value           *string
	clearedFields   map[string]struct{}
	variants        map[uint64]struct{}
	removedvariants map[uint64]struct{}
	clearedvariants bool
	done            bool
	oldValue        func(context.Context) (*Variation, error)
	predicates      []predicate.Variation
}

var _ ent.Mutation = (*VariationMutation)(nil)

// variationOption allows to manage the mutation configuration using functional options.
type variationOption func(*VariationMutation)

// newVariationMutation creates new mutation for Variation.
func newVariationMutation(c config, op Op, opts ...variationOption) *VariationMutation {
	m := &VariationMutation{
		config:        c,
		op:            op,
		typ:           TypeVariation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVariationID sets the id field of the mutation.
func withVariationID(id uint64) variationOption {
	return func(m *VariationMutation) {
		var (
			err   error
			once  sync.Once
			value *Variation
		)
		m.oldValue = func(ctx context.Context) (*Variation, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Variation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVariation sets the old Variation of the mutation.
func withVariation(node *Variation) variationOption {
	return func(m *VariationMutation) {
		m.oldValue = func(context.Context) (*Variation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VariationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VariationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *VariationMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetType sets the type field.
func (m *VariationMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the type value in the mutation.
func (m *VariationMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the Variation.
// If the Variation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VariationMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *VariationMutation) ResetType() {
	m._type = nil
}

// SetValue sets the value field.
func (m *VariationMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value value in the mutation.
func (m *VariationMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old value value of the Variation.
// If the Variation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VariationMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue reset all changes of the "value" field.
func (m *VariationMutation) ResetValue() {
	m.value = nil
}

// AddVariantIDs adds the variants edge to Variant by ids.
func (m *VariationMutation) AddVariantIDs(ids ...uint64) {
	if m.variants == nil {
		m.variants = make(map[uint64]struct{})
	}
	for i := range ids {
		m.variants[ids[i]] = struct{}{}
	}
}

// ClearVariants clears the variants edge to Variant.
func (m *VariationMutation) ClearVariants() {
	m.clearedvariants = true
}

// VariantsCleared returns if the edge variants was cleared.
func (m *VariationMutation) VariantsCleared() bool {
	return m.clearedvariants
}

// RemoveVariantIDs removes the variants edge to Variant by ids.
func (m *VariationMutation) RemoveVariantIDs(ids ...uint64) {
	if m.removedvariants == nil {
		m.removedvariants = make(map[uint64]struct{})
	}
	for i := range ids {
		m.removedvariants[ids[i]] = struct{}{}
	}
}

// RemovedVariants returns the removed ids of variants.
func (m *VariationMutation) RemovedVariantsIDs() (ids []uint64) {
	for id := range m.removedvariants {
		ids = append(ids, id)
	}
	return
}

// VariantsIDs returns the variants ids in the mutation.
func (m *VariationMutation) VariantsIDs() (ids []uint64) {
	for id := range m.variants {
		ids = append(ids, id)
	}
	return
}

// ResetVariants reset all changes of the "variants" edge.
func (m *VariationMutation) ResetVariants() {
	m.variants = nil
	m.clearedvariants = false
	m.removedvariants = nil
}

// Op returns the operation name.
func (m *VariationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Variation).
func (m *VariationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *VariationMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._type != nil {
		fields = append(fields, variation.FieldType)
	}
	if m.value != nil {
		fields = append(fields, variation.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *VariationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case variation.FieldType:
		return m.GetType()
	case variation.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *VariationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case variation.FieldType:
		return m.OldType(ctx)
	case variation.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Variation field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *VariationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case variation.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case variation.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Variation field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *VariationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *VariationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *VariationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Variation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *VariationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *VariationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *VariationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Variation nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *VariationMutation) ResetField(name string) error {
	switch name {
	case variation.FieldType:
		m.ResetType()
		return nil
	case variation.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Variation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *VariationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.variants != nil {
		edges = append(edges, variation.EdgeVariants)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *VariationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case variation.EdgeVariants:
		ids := make([]ent.Value, 0, len(m.variants))
		for id := range m.variants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *VariationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedvariants != nil {
		edges = append(edges, variation.EdgeVariants)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *VariationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case variation.EdgeVariants:
		ids := make([]ent.Value, 0, len(m.removedvariants))
		for id := range m.removedvariants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *VariationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvariants {
		edges = append(edges, variation.EdgeVariants)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *VariationMutation) EdgeCleared(name string) bool {
	switch name {
	case variation.EdgeVariants:
		return m.clearedvariants
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *VariationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Variation unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *VariationMutation) ResetEdge(name string) error {
	switch name {
	case variation.EdgeVariants:
		m.ResetVariants()
		return nil
	}
	return fmt.Errorf("unknown Variation edge %s", name)
}
